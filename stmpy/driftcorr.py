from __future__ import print_function
import stmpy
import numpy as np
import scipy as sp
import matplotlib as mpl
import matplotlib.pyplot as plt
import scipy.optimize as opt
import scipy.ndimage as snd
from scipy.interpolate import interp1d, interp2d
from skimage import transform as tf
from skimage.feature import peak_local_max
#import stmpy.driftcorr as dfc

'''
Local drift correction of square/triangular lattice. (Please carefully rewrite if a rectangular lattice version is needed.)

Usage:
0. please import stmpy.driftcorr (Package 'skimage' required, run 'pip install -U scikit-image' in terminal);

1. findBraggs: FT the topo image (please interpolate to be 2D square array if not), then find all Bragg peaks by peak_local_max, plot result with abs(FT) to check validity (sometimes points in the center should be removed);

2. gshearcorr: global shear correction, outputs corrected image and positions of the corrected Bragg peaks;

3. phasemap: use the new Bragg peaks to generate local phase shift (theta) maps. Use chkphasemap get phase (phi) maps and check if pi lines in those matches with raw image. If not, please check your Bragg peaks or adjust sigma in the FT DC filter;

4. fixphaseslip: fix phase slips of 2d phase maps in a 1d spiral way.(this is not well developed yet. Phase slips could still be present 
near edges after processing, please crop images and DOS maps accordingly and manually AFTER applying driftmap.) Output is 2d array in the same shape as the input array;

5. driftmap: calculate drift fields u(x,y) in both x and y directions;

6. driftcorr: local drift correction using u(x,y) on 2D (topo) or 3D(DOS map) input.

7. (OPTIONAL) chkperflat: check perfect lattice generated by Q1, Q2 (to be improved)

REFERENCES: 
[1] MH Hamidian, et al. "Picometer registration of zinc impurity states in Bi2Sr2CaCu2O8+d for phase determination in intra-unit-cell Fourier transform STM", New J. Phys. 14, 053017 (2012).
[2] JA Slezak, PhD thesis (Ch. 3), http://davisgroup.lassp.cornell.edu/theses/Thesis_JamesSlezak.pdf

History:
    2017-04-28      CREATED BY JIANFENG GE
    04/29/2019      RL : Add documents for all functions. Add another method to calculate phasemap.
                            Add inverse FFT method to apply the drift field.
'''

def findBraggs(A, min_dist=5, thres=0.25, rspace=True, maskon=True, outAll=False, show=False):
    '''
    Find Bragg peaks in the unit of pixels of topo or FT pattern A using peak_local_max.

    Input: 
        A           - Required : 2D array of topo in real space, or FFT in q space.
        min_dist    - Optional : Minimum distance (in pixels) between peaks. Default: 5
        thres       - Optional : Minimum intensity of Bragg peaks relative to max value. Default: 0.25
        rspace      - Optional : Boolean indicating if A is real or Fourier space image. Default: True
        maskon      - Optional : Boolean, if True then a Gaussian mask (width=len(A)/5) will be used to 
                                    remove low q high intensity signals before finding Bragg peaks.
        outAll      - Optional : Boolean, if False then only the first two and last two peaks will be output.
                                    If True then all Bragg peaks will be output.
        show        - Optional : Boolean, if True then A and Bragg peaks will be plotted out.

    Returns:
        coords      -  (4x2) array contains Bragg peaks in the format of [[x1,y1],[x2,y2],...,[x4,y4]]

    Usage:
        import stmpy.driftcorr as dfc
        bg = dfc.findBraggs(A, min_dist=10, thres=0.2, rspace=True,show=True)

    History:
        04/28/2017      JG : Initial commit.
        04/29/2019      RL : Add maskon option, add outAll option, and add documents.

    '''
    if rspace is True:
        F = stmpy.tools.fft(A, zeroDC=True)
    else:
        F = np.copy(A)
    # Remove low-q high intensity data with Gaussian mask
    if maskon is True:
        X, Y = np.shape(A)
        Lx = X/5
        Ly = Y/5
        x = np.arange(X)
        y = np.arange(Y)
        p0 = [int(X/2), int(Y/2), Lx, Ly, 1, np.pi/2]
        G = 1-stmpy.tools.gauss2d(x, y, p=p0)
        F *= G
    cnorm = mpl.colors.Normalize(vmin=F.min(), vmax=F.max())
    #if norm is 'log':
    #    cnorm = mpl.colors.LogNorm(vmin=F.mean(), vmax=F.max())
    coords = peak_local_max(F, min_distance=min_dist, threshold_rel=thres)
    coords = np.fliplr(coords)
    if show is True:
        plt.imshow(F, cmap=plt.cm.gray_r, interpolation='None', origin='lower left', norm=cnorm, aspect=1)
        plt.plot(coords[:, 0], coords[:, 1], 'r.')
        plt.gca().set_aspect(1)
        plt.axis('tight')
        print('#:\t[x y]')
        for ix, iy in enumerate(coords):
            print(ix, end='\t')
            print(iy)
    if outAll is False:
        if len(coords) > 4:
            coords = np.delete(coords, np.arange(len(coords)-4)+2,axis=0)
    return coords
    
def gshearcorr(A, Bragg, rspace=True, slow_scan='None'):
    '''
    Global shear correction based on FT of 2D array A

    Inputs:
        A           - Required : 2D or 3D array to be shear corrected.
        Bragg       - Required : (Nx2) array contains Bragg peaks in the unit of pixels.
        rspace      - Optional : Boolean indicating if A is real or Fourier space image. Default: True
        slow_scan   - Optional : One of ("None", "x", "y"), specifying the slow scan direction.
    
    Returns:
        A_corr      - 2D or 3D array after global shear correction.
        Bragg_M     - model points for Bragg peaks

    Usage:
        import stmpy.driftcorr as dfc
        A_gcorr, bg_m = dfc.gshearcorr(A, Bragg, rspace=True, slow_scan='y')
    '''
    
    A_corr = np.zeros_like(A)
    if len(Bragg.shape) is 2 and Bragg.shape[1] is 2:
        if len(A.shape) is 2:
            tform, Bragg_M = calctform(Bragg, A.shape[-1], slow_scan=slow_scan)
            A_corr = corr2d(A, tform, rspace=rspace)
            return A_corr, Bragg_M
        if len(A.shape) is 3:
            tform, Bragg_M = calctform(Bragg, A.shape[-1], slow_scan=slow_scan)
            for ix, layer in enumerate(A):
                A_corr[ix] = corr2d(layer, tform, rspace=rspace)
            return A_corr, Bragg_M
        else:
            print('ERR: Input must be 2D or 3D numpy array!')
    else:
        print('Bragg peak coordinates should be 2D array of the shape (N, 2)')

def phasemap(A, Br_c, sigma=10, method="lockin"):
    '''
    Calculate local phase and phase shift maps. Two methods are available now: spatial lockin or Gaussian mask convolution

    Input:
        A       - Required : 2D arrays after global shear correction with bad pixels cropped on the edge
        Br_c    - Required : Coords of Bragg peaks of FT(A), can be computed by findBraggs(A)
        sigma   - Optional : width of DC filter in lockin method or len(A)/s
        method  - Optional : Specify which method to use to calculate phase map.
                                "lockin": Spatial lock-in method to find phase map
                                "convolution": Gaussian mask convolution method to find phase map

    Returns:
        thetax      -       2D array, Phase shift map in x direction, relative to perfectly generated cos lattice
        thetay      -       2D array, Phase shift map in y direction, relative to perfectly generated cos lattice
        Q1          -       Coordinates of 1st Bragg peak
        Q2          -       Coordinates of 2nd Bragg peak
    
    Usage:
        import stmpy.driftcorr as dfc
        thetax, thetay, Q1, Q2 = dfc.phasemap(A, Br_c, sigma=10, method='lockin')
    
    History:
        04/28/2017      JG : Initial commit.
        04/29/2019      RL : Add "convolution" method, and add documents.

    '''
    if A.shape[1] != A.shape[0]:
        print('Input is not a square 2D array!')
    else:
        s = A.shape[-1]
        Br_c = sortBraggs(Br_c, s)
        t = np.arange(s, dtype='float')
        x, y = np.meshgrid(t, t)
        Q1 = 2*np.pi*np.array([Br_c[0][0]-s/2, Br_c[0][1]-s/2])/s
        Q2 = 2*np.pi*np.array([Br_c[1][0]-s/2, Br_c[1][1]-s/2])/s
        if method is "lockin":
            Axx = A * np.sin(Q1[0]*x+Q1[1]*y)
            Axy = A * np.cos(Q1[0]*x+Q1[1]*y)
            Ayx = A * np.sin(Q2[0]*x+Q2[1]*y)
            Ayy = A * np.cos(Q2[0]*x+Q2[1]*y)
            Axxf = FTDCfilter(Axx, sigma)
            Axyf = FTDCfilter(Axy, sigma)
            Ayxf = FTDCfilter(Ayx, sigma)
            Ayyf = FTDCfilter(Ayy, sigma)
            thetax = np.arctan2(Axxf, Axyf)
            thetay = np.arctan2(Ayxf, Ayyf)
            return thetax, thetay, Q1, Q2
        elif method is "convolution":
            t_x = np.arange(s)
            t_y = np.arange(s)
            xcoords, ycoords = np.meshgrid(t_x, t_y)
            exponent_x = (Q1[0] * xcoords + Q1[1] * ycoords)#(2.* np.pi/s)*(Q1[0] * xcoords + Q1[1] * ycoords)
            exponent_y = (Q2[0] * xcoords + Q2[1] * ycoords)#(2.* np.pi/s)*(Q2[0] * xcoords + Q2[1] * ycoords)
            A_x = A * np.exp(np.complex(0,-1)*exponent_x)
            A_y = A * np.exp(np.complex(0,-1)*exponent_y)
            sx = sigma
            sy = sigma
            Amp = 1/(4*np.pi*sx*sy)
            p0 = [int(s/2), int(s/2), sx, sy, Amp, np.pi/2]
            G = stmpy.tools.gauss2d(t_x, t_y, p=p0, symmetric=True)
            T_x = sp.signal.fftconvolve(A_x, G, mode='same',)
            T_y = sp.signal.fftconvolve(A_y, G, mode='same',)
            R_x = np.abs(T_x)
            R_y = np.abs(T_y)
            phi_y = np.angle(T_y)    
            phi_x = np.angle(T_x) 
            return phi_x, phi_y, Q1, Q2
        else:
            print('Only two methods are available now:\n1. lockin\n2. convolution')

def chkphasemap(A, thetax, thetay, Q1, Q2, l=-0.95):
    '''
    Compare phase map with phi=pi lines.
    A - 2D array used to calculate phasemap
    l - a value a bit large than cos(pi)=-1 to draw the contour
    '''
    s = A.shape[-1]
    t = np.arange(s)
    x, y = np.meshgrid(t, t)
    phix = np.mod(-thetax + Q1[0]*x + Q1[1]*y, 2*np.pi)
    phiy = np.mod(-thetay + Q2[0]*x + Q2[1]*y, 2*np.pi)
    
    plt.figure(figsize=[8, 4])
    plt.subplot(121)
    plt.imshow(A, cmap=plt.cm.gray, interpolation='None', origin='lower left')
    plt.contour(x, y, np.cos(phix), [l], colors='m', origin='lower', linewidths=0.5, nchunk=0)
    plt.gca().set_aspect(1)
    plt.subplot(122)
    plt.imshow(A, cmap=plt.cm.gray, interpolation='None', origin='lower left')
    plt.contour(x, y, np.cos(phiy), [l], colors='y', origin='lower', linewidths=0.5, nchunk=0)
    plt.tight_layout()
    return phix, phiy

def fixphaseslip(A, thres=None, method='unwrap', orient=0):
    '''
    Fix phase slip by adding 2*pi at phase jump lines.

    Inputs:
        A       - Required : 2D arrays of phase shift map, potentially containing phase slips
        thres   - Optional : Float number, specifying threshold for finding phase jumps in diff(A). Default: None
        method  - Optional : Specifying which method to fix phase slips.
                                "unwrap": fix phase jumps line by line in x direction and y direction, respectively
                                "spiral": fix phase slip in phase shift maps by flattening A into a 1D array in a spiral way
        orient  - Optional : Used in "spiral" phase fixing method. 0 for clockwise and 1 for counter-clockwise

    Returns:
    
        phase_corr      -       2D arrays of phase shift map with phase slips corrected

    Usage:
        import stmpy.driftcorr as dfc
        thetaxf = dfc.fixphaseslip(thetax, method='unwrap')

    History:
        04/28/2017      JG : Initial commit.
        04/29/2019      RL : Add "unwrap" method, and add documents.
    '''
    def fixphaseslip1d(A, thres=np.pi):
        dA = np.diff(A, 1)
        slips = np.where(np.absolute(dA)>thres)[0]
        sliprm = np.zeros_like(A)
        for slip in slips:
            sliprm[:slip+1] += 2 * np.pi * np.sign(dA[slip])
        return A+sliprm

    if method is 'spiral':
        if thres is None:
            thres=np.pi
        if A.shape[0] != A.shape[1]:
            print('ERR: Input must be a square 2D array!')
        else:
            C = np.array([], dtype=A.dtype)
            n = A.shape[0]
            B = np.copy(A)
            if orient is 1:
                B = B.T
            for ix in range(int((n-1)/2)):
                C = np.append(C, B[0, :-1])
                C = np.append(C, B[:-1, -1])
                C = np.append(C, B[-1, -1:0:-1])
                C = np.append(C, B[-1:0:-1, 0])
                B = B[1:-1, 1:-1]
            if n%2:
                C = np.append(C, B[0, 0])
            else:
                C = np.append(C, B[0, :])
                C = np.append(C, B[-1, ::-1])
            
            D = fixphaseslip1d(C, thres=thres)
        
            D = D[::-1]
            if n%2:
                E, D = np.split(D, [1])
                E = E.reshape(1,1)
                start = 2
            else:
                E, D = np.split(D, [4])
                E = E[::-1].reshape(2,2)
                E[-1] = E[-1, ::-1]
                start = 3
            for ix in range(start, n, 2):
                E = np.pad(E, ((1, 1), (1, 1)), mode='constant')
                D1, D2, D3, D4, D = np.split(D, [ix, ix*2, ix*3, ix*4])
                E[1:, 0] = D1
                E[-1, 1:] = D2
                E[-2::-1, -1] = D3
                E[0, -2::-1] = D4
            if orient is 1:
                E = E.T
            return E
    elif method is "unwrap":
        return unwrap_phase_2d(A, thres=thres)
    else:
        print('Method not implemented!')

def driftmap(thetax, thetay, Q1, Q2, method="lockin"):
    '''
    Calculate drift fields based on phase shift maps, with Q1 and Q2 generated by phasemap.

    Inputs:
        thetax      - Required : 2D arrays of phase shift map in x direction with phase slips corrected
        thetay      - Required : 2D arrays of phase shift map in y direction with phase slips corrected
        Q1          - Required : Coordinates of 1st Bragg peak, generated by phasemap
        Q2          - Required : Coordinates of 2nd Bragg peak, generated by phasemap
        method      - Optional : Specifying which method to use.
                                    "lockin": Used for phase shift map generated by lockin method
                                    "convolution": Used for phase shift map generated by lockin method

    Returns:
        ux          - 2D array of drift field in x direction
        uy          - 2D array of drift field in y direction

    Usage:
        import stmpy.driftcorr as dfc
        ux, uy = dfc.driftmap(thetaxf, thetayf, Q1, Q2, method='lockin')

    History:
        04/28/2017      JG : Initial commit.
        04/29/2019      RL : Add "lockin" method, and add documents.
    '''
    if method is "lockin":
        tx = np.copy(thetax)
        ty = np.copy(thetay)
        #tx -= tx.mean()
        #ty -= ty.mean()
        ux = -(Q2[1]*tx - Q1[1]*ty) / (Q1[0]*Q2[1]-Q1[1]*Q2[0])
        uy = -(Q2[0]*tx - Q1[0]*ty) / (Q1[1]*Q2[0]-Q1[0]*Q2[1])
        return ux, uy
    elif method is "convolution":
        #s = np.shape(thetax)[-1]
        Qx_mag = np.sqrt((Q1[0])**2 + (Q1[1])**2)
        Qy_mag = np.sqrt((Q2[0])**2 + (Q2[1])**2)
        Qx_ang = np.arctan2(Q1[1],Q1[0]) # in radians
        Qy_ang = np.arctan2(Q2[1],Q2[0]) # in radians
        Qxdrift = 1/(Qx_mag) * thetax#s/(2*np.pi*Qx_mag) * thetax
        Qydrift = 1/(Qy_mag) * thetay#s/(2*np.pi*Qy_mag) * thetay
        ux = Qxdrift * np.cos(Qx_ang) - Qydrift * np.sin(Qy_ang-np.pi/2)
        uy = Qxdrift * np.sin(Qx_ang) + Qydrift * np.cos(Qy_ang-np.pi/2)
        return -ux, -uy
    else:
        print("Only two methods are available now:\n1. lockin\n2. convolution")

def driftcorr(A, ux, uy, method="interpolate", interpolation='cubic'):
    '''
    Correct the drift in the topo according to drift fields

    Inputs:
        A           - Required : 2D or 3D arrays of topo to be drift corrected
        ux          - Required : 2D arrays of drift field in x direction, generated by driftmap()
        uy          - Required : 2D arrays of drift field in y direction, generated by driftmap()
        method      - Optional : Specifying which method to use.
                                    "interpolate": Interpolate A and then apply it to a new set of coordinates,
                                                    (x-ux, y-uy)
                                    "invfft": Used inversion fft to apply the drift fields
        interpolation - Optional : Specifying which method to use for interpolating

    Returns:
        A_corr      - 2D or 3D array of topo with drift corrected

    Usage:
        import stmpy.driftcorr as dfc
        A_corr = dfc.driftcorr(ux, uy, method='interpolate', interpolation='cubic')

    History:
        04/28/2017      JG : Initial commit.
        04/29/2019      RL : Add "invfft" method, and add documents.
    '''
    if method is "interpolate":
        A_corr = np.zeros_like(A)
        s = A.shape[-1]
        t = np.arange(s, dtype='float')
        x, y = np.meshgrid(t, t)
        xnew = (x - ux).ravel()
        ynew = (y - uy).ravel()
        tmp = np.zeros(s**2)
        if len(A.shape) is 2:
            tmp_f = interp2d(t, t, A, kind=interpolation)
            for ix in range(tmp.size):
                tmp[ix] = tmp_f(xnew[ix], ynew[ix])
            A_corr = tmp.reshape(s, s)
            return A_corr
        elif len(A.shape) is 3:
            for iz, layer in enumerate(A):
                tmp_f = interp2d(t, t, layer, kind=interpolation)
                for ix in range(tmp.size):
                    tmp[ix] = tmp_f(xnew[ix], ynew[ix])
                A_corr[iz] = tmp.reshape(s, s)
                print('Processing slice %d/%d...'%(iz+1, A.shape[0]), end='\r')
            return A_corr
        else:
            print('ERR: Input must be 2D or 3D numpy array!')
    elif method is "invfft":
        A_corr = np.zeros_like(A)
        if len(A.shape) is 2:
            return apply_drift_field(A, ux=ux, uy=uy, zeroOut=True)
        elif len(A.shape) is 3:
            for iz, layer in enumerate(A):
                A_corr[iz] = apply_drift_field(layer, ux=ux, uy=uy, zeroOut=True)
                print('Processing slice %d/%d...'%(iz+1, A.shape[0]), end='\r')
            return A_corr
        else:
            print('ERR: Input must be 2D or 3D numpy array!')

def apply_drift_field(A, ux, uy, zeroOut=True):
    A_corr = np.copy(A)
    s = A.shape[-1]
    t = np.arange(s, dtype='float')
    x, y = np.meshgrid(t, t)
    xshifted = x + ux
    yshifted = y + uy
    if zeroOut is True:
        A_corr[np.where(xshifted < 0)] = 0
        A_corr[np.where(yshifted < 0)] = 0
        A_corr[np.where(xshifted > s)] = 0
        A_corr[np.where(yshifted > s)] = 0
    qcoord = (2*np.pi/s)*(np.arange(s)-(int(s/2)))
    xshifted = np.reshape(xshifted, [1, s**2])
    yshifted = np.reshape(yshifted, [1, s**2])
    qcoord = np.reshape(qcoord, [s, 1])
    xphase = np.exp(-1j*(np.matmul(xshifted.T, qcoord.T).T))
    yphase = np.exp(-1j*(np.matmul(yshifted.T, qcoord.T).T))
    avgData = np.mean(A_corr)
    A_corr -= avgData
    A_corr = np.reshape(A_corr, s**2)
    data_temp = np.zeros([s, s**2])
    for i in range(s):
        data_temp[i] = A_corr
    FT = np.matmul(data_temp * xphase, yphase.T).T
    invFT = np.fft.ifft2(np.fft.fftshift(FT)) + avgData
    return np.real(invFT)

def chkperflat(A_corr, Q1, Q2, shiftx=0, shifty=0):
    '''check corrected topo image with perfect lattice. Manually find smallest shifts of x and y in corrected image to align atoms'''
    s = A_corr.shape[-1]
    t = np.arange(s*10, dtype='float')
    x, y = np.meshgrid(t, t)
    Q3 = Q1-Q2 #2*np.pi*np.array([Bragg_c[2][0]-s/2, Bragg_c[2][1]-s/2])/s
    P = np.cos(Q1[0]/10*x+Q1[1]/10*y)+np.cos(Q2[0]/10*x+Q2[1]/10*y)+np.cos(Q3[0]/10*x+Q3[1]/10*y)
    P = np.roll(P, int(shifty*10), axis=0)
    P = np.roll(P, int(shiftx*10), axis=1)
    perflat = peak_local_max(P, min_distance=5, threshold_rel=0.7)
    perflat = np.fliplr(perflat)
    plt.imshow(A_corr, cmap=plt.cm.afmhot, interpolation='None', origin='lower left')
    plt.plot(perflat[:, 0]/10, perflat[:, 1]/10, 'b.')
    plt.gca().set_aspect(1)
    plt.axis('tight')

##################################################################################
####################### Useful functions in the processing #######################
##################################################################################

def squareinterp(A, kind='linear'):
    '''
    Square rectangular 2D arrays (For 3D arrays, sqaure each slice), by interpolating short axis to the same length of the long axis
    kind can be 'linear', 'cubic' or 'quintic'
    '''
    x = A.shape[-1]
    y = A.shape[-2]
    xx = np.linspace(0, 1, x)
    yy = np.linspace(0, 1, y)
    s = max(x, y)
    ss = np.linspace(0, 1, s)
    if len(A.shape) is 2:
        B = np.zeros((s, s))
        f = interp2d(xx, yy, A, kind=kind)
        B = f(ss, ss)
        return B
    elif len(A.shape) is 3:
        B = np.zeros((A.shape[0], s, s))
        for ix, layer in enumerate(A):
           f = interp2d(xx, yy, layer, kind=kind)
           B[ix] = f(ss, ss)
        return B
    else:
        print('ERR: Input must be 2D or 3D numpy array!')

def sortBraggs(Br, s):
    ''' sort Bragg peaks in conter-clockwise way around center, image shape is (s, s) '''
    Br_s = np.copy(Br)
    c = int((s+1)/2)
    xn = Br_s[:, 0]/c-1
    yn = Br_s[:, 1]/c-1
    theta = np.arctan2(yn, xn)
    atansorted = np.asarray(sorted((atanval, ix) for ix, atanval in enumerate(theta)))# sort angles of vertices in rad
    tanseq = np.int_(atansorted[:, 1])
    Br_s = Br_s[tanseq] # sort Bragg peaks accordingly
    return Br_s

def calctform(Br, s, slow_scan):
    ''' 
    calculate projective transform matrix by Bragg peaks Br with coordinates in the range of F.shape
    slow_scan: None

    '''
    N = Br.shape[0]
    c = s*0.5
    Br = sortBraggs(Br, s)
    xn = Br[:, 0]/c-1
    yn = Br[:, 1]/c-1
    R = np.mean(np.sqrt(xn**2+yn**2))
    theta = np.arctan2(yn, xn)
    theta_M = (np.arange(N)*2./N-1)*np.pi # Model angles of vertices, in rad, range (-pi, pi)
    dtheta = np.mean(theta - theta_M)
    xn_M = R * np.cos(theta_M+dtheta) # Generate Model coordinates
    yn_M = R * np.sin(theta_M+dtheta) # based on first point

    # rescale for fast scan direction, i.e. trust the coordinate of the fast scan direction
    if slow_scan is 'y':
        R *= np.mean(abs(yn/yn_M))
        xn_M = R * np.cos(theta_M+dtheta) # Generate Model coordinates
        yn_M = R * np.sin(theta_M+dtheta)
    if slow_scan is 'x':
        R *= np.mean(abs(xn/xn_M))
        xn_M = R * np.cos(theta_M+dtheta) # Generate Model coordinates
        yn_M = R * np.sin(theta_M+dtheta)
    Br_M = np.concatenate(((xn_M+1)*c, (yn_M+1)*c)).reshape(2, N).T # Back to original coordinates
    tform = tf.ProjectiveTransform()
    if tform.estimate(Br_M, Br):
        return tform, Br_M
            
def corr2d(A, tform, rspace=True):
    ''' shear correction of 2d image in real or reciprocal space, called by gshearcorr'''
    matrix = np.copy(tform.params)
    A_corr2d = np.zeros_like(A)
    # calctform is used to estimate transformation matrix in reciprocal space
    # NOTE: warp function use inverse matrix to do forward transformation
    # in real space the inverse matrix does not equal to tform.params, because translation operation after inverse FT vanishes
    # Due to fftshift the origin of FT differs from that in real space, which should be changed before applying transformation

    if rspace:
        matrix[-1, :] = np.array([0., 0., 1.])
        matrix[:, -1] = np.array([0., 0., 1.])
        A_corr2d = tf.warp(np.flipud(A.T), matrix, preserve_range=True, order=5)
        A_corr2d = np.flipud(A_corr2d).T
    else:
        A_corr2d = tf.warp(A, matrix, preserve_range=True, order=5)
    return A_corr2d

def cropedge(A, n):
    ''' crop off n pixel from edges of Topo image or each layer of DOS map accordingly, useful after shear correction and fixphaseslip'''
    B = np.copy(A)
    if len(B.shape) is 2:
        B = B[n:-n, n:-n]
    elif len(B.shape) is 3:
        B = B[:, n:-n, n:-n]
    else:
        print('ERR: Input must be 2D or 3D numpy array!')
    print('Shape before crop:', end=' ')
    print(A.shape)
    print('Shape after crop:', end=' ')
    print(B.shape)
    return B

def Gaussian2d(x, y, sigma_x, sigma_y, theta, x0, y0, Amp):
    '''
    x, y: ascending 1D array
    x0, y0: center
    '''
    a = np.cos(theta)**2/2/sigma_x**2 + np.sin(theta)**2/2/sigma_y**2
    b = -np.sin(2*theta)**2/4/sigma_x**2 + np.sin(2*theta)**2/4/sigma_y**2
    c = np.sin(theta)**2/2/sigma_x**2 + np.cos(theta)**2/2/sigma_y**2
    z = np.zeros((len(x), len(y)))
    X, Y = np.meshgrid(x, y)
    z = Amp * np.exp(-(a*(X-x0)**2 + 2*b*(X-x0)*(Y-y0) + c*(Y-y0)**2))
    return z

def FTDCfilter(A, sigma):
    '''
    Filtering DC component of Fourier transform and inverse FT, using a gaussian with one parameter sigma
    A is a 2D array, sigma is in unit of px
    '''
    if A.shape[1] != A.shape[0]:
        print('ERR: not a sqare FFT!')
    else:
        n = A.shape[1]
        m = np.arange(n, dtype='float')
        c = np.float((n-1)/2)
    g = Gaussian2d(m, m, sigma, sigma, 0, c, c, 1)
    ft_A = np.fft.fftshift(np.fft.fft2(A))
    ft_Af = ft_A * g
    Af = np.fft.ifft2(np.fft.ifftshift(ft_Af))
    return np.real(Af)

def chkphaseslip(thetax, thetay):
    ''' check phase slips by differentiate on both axes '''
    dthetax0 = np.diff(thetax, axis=0)
    dthetax1 = np.diff(thetax, axis=1)
    dthetay0 = np.diff(thetay, axis=0)
    dthetay1 = np.diff(thetay, axis=1)
    dtheta = [dthetax0, dthetax1, dthetay0, dthetay1]
    s = thetax.shape[0]
    plt.figure(figsize=[8, 8])
    for ix in range(4):
        plt.subplot(2, 2, ix+1)
        plt.imshow(dtheta[ix]/np.pi, cmap=plt.cm.bwr, interpolation='None', origin='lower left')
        plt.gca().set_aspect(1)
        plt.clim(-2, 2)
        plt.xlim(0, s)
        plt.ylim(0, s)
        plt.colorbar(fraction=0.03)
    plt.tight_layout()

def spiralflatten(A, orient=0):
    '''
    Spiral flattening a square(?) 2D array
    orient: orientation, 0 for clockwise, 1 for counter-clockwise
    '''
    C = np.array([], dtype=A.dtype)
    n = A.shape[-1]
    B = np.copy(A)
    if orient is 1:
        B = B.T
    for ix in range(int((n-1)/2)):
        C = np.append(C, B[0, :-1])
        C = np.append(C, B[:-1, -1])
        C = np.append(C, B[-1, -1:0:-1])
        C = np.append(C, B[-1:0:-1, 0])
        B = B[1:-1, 1:-1]
    if n%2:
        C = np.append(C, B[0, 0])
    else:
        C = np.append(C, B[0, :])
        C = np.append(C, B[-1, ::-1])
    return C

def spiralroll(B, orient=1):
    ''' undo spiral flatten '''
    k = int(np.sqrt(B.size))
    if k**2-B.size != 0:
        print('ERR: unable to form a square 2D array!')
    else:
        C = np.copy(B)
        C = C[::-1]
        if k%2:
            A, C = np.split(C, [1])
            A = A.reshape(1,1)
            start = 2
        else:
            A, C = np.split(C, [4])
            A = A[::-1].reshape(2,2)
            A[-1] = A[-1, ::-1]
            start = 3
        for ix in range(start, k, 2):
            A = np.pad(A, ((1, 1), (1, 1)), mode='constant')
            C1, C2, C3, C4, C = np.split(C, [ix, ix*2, ix*3, ix*4])
            A[1:, 0] = C1
            A[-1, 1:] = C2
            A[-2::-1, -1] = C3
            A[0, -2::-1] = C4
        if orient is 0:
            A = A.T
        return A
def findBZvertices(A, Br):
    '''
    Find vertices of Brillouin zone (BZ) based on coordinates of Bragg peaks in Fourier space image.
    
    A: 2-D array, Fourier transformed image
    Br: (N, 2) array, coordinates of all Bragg peaks
    output: coordinates of BZ vertices
    usage: K = findBZvertices(FT, Br)
    plot together with FT image: imshow(FT, origin='lower left'); gca().add_patch(Polygon(V, fill=None, color='b'))
    '''
    def findV(C, B1, B2):
        C = np.array(C)
        B1 = np.array(B1-C)
        B2 = np.array(B2-C)
        theta1 = np.arctan2(B1[1], B1[0]) + np.pi/2.
        theta2 = np.arctan2(B2[1], B2[0]) + np.pi/2.
        V = np.linalg.solve(np.array([[-np.tan(theta1), 1], [-np.tan(theta2), 1]]), np.array([B1[1]/2.-np.tan(theta1)*B1[0]/2., B2[1]/2.-np.tan(theta2)*B2[0]/2.]))
        return C + V

    C = np.array(A.shape[-2:])/2.
    Br = np.array(Br)
    Br = sortBraggs(Br, A.shape[0])
    N = Br.shape[0]
    V = np.zeros_like(Br)
    for ix in range(N-1):
        V[ix] = findV(C, Br[ix], Br[ix+1])
    V[-1] = findV(C, Br[-1], Br[0])
    return V

def unwrap_phase(ph, tolerance=None, maxval=None):

    maxval = 2 * np.pi if maxval is None else maxval0
    tol = 0.25*maxval if tolerance is None else tolerance*maxval
    if len(ph) < 2:
        return ph

    dph = np.diff(ph)
    dph[np.where(np.abs(dph) < tol)] = 0
    dph[np.where(dph < -tol)] = 1
    dph[np.where(dph > tol)] = -1
    ph[1:] += maxval * np.cumsum(dph)
    return ph

def unwrap_phase_2d(A, thres=None):
    output = np.copy(A[::-1,::-1])         
    if len(np.shape(A)) == 2:
        n = np.shape(A)[-1]
        for i in range(n):
            output[i,:] = unwrap_phase(output[i,:], tolerance=thres)
        for i in range(n):
            output[:,i] = unwrap_phase(output[:,i], tolerance=thres)
        return output[::-1,::-1]

def global_corr(data, show=False):
    """
    Global shear correct the 2D topo automatically.

    Inputs:
        data    - Required : 2D array of topo to be shear corrected.
        show    - Optional : Boolean specifying if the results are plotted or not

    Returns:
        bg_1    - Bragg peaks returned by gshearcorr. To be used in local_corr()
        data_1  - 2D array of topo after global shear correction

    Usage:
        import stmpy.driftcorr as dfc
        bg1, data1 = dfc.global_corr(data, show=True)

    History:
        04/29/2019      RL : Initial commit.
    """
    imgsize = np.shape(data)[-1]
    bg_1 = findBraggs(data, min_dist=int(imgsize/10), thres=0.2, show=show)
    data_1, Bragg_M = gshearcorr(data, bg_1, rspace=True)
    if show is True:
        fig,ax=plt.subplots(1,2,figsize=[8,4])
        ax[0].imshow(data_1, cmap=stmpy.cm.blue2,origin='lower')
        ax[1].imshow(stmpy.tools.fft(data_1, zeroDC=True), cmap=stmpy.cm.gray_r,origin='lower')
        fig.suptitle('After global shear correction', fontsize=14)
        fig,ax=plt.subplots(2,2,figsize=[8,8])
        ax[0,0].imshow(data_1, cmap=stmpy.cm.blue2,origin='lower')
        ax[0,1].imshow(data_1, cmap=stmpy.cm.blue2,origin='lower')
        ax[1,0].imshow(data_1, cmap=stmpy.cm.blue2,origin='lower')
        ax[1,1].imshow(data_1, cmap=stmpy.cm.blue2,origin='lower')
        ax[0,0].set_xlim(0, imgsize/10)
        ax[0,0].set_ylim(imgsize-imgsize/10, imgsize)
        ax[0,1].set_xlim(imgsize-imgsize/10, imgsize)
        ax[0,1].set_ylim(imgsize-imgsize/10, imgsize)
        ax[1,0].set_xlim(0, imgsize/10)
        ax[1,0].set_ylim(0, imgsize/10)
        ax[1,1].set_xlim(imgsize-imgsize/10, imgsize)
        ax[1,1].set_ylim(0, imgsize/10)
        fig.suptitle('Bad pixels in 4 corners', fontsize=14)
    return bg_1, data_1

def local_corr(data, sigma=10, method="lockin", fixMethod='unwrap', show=False):
    """
    Locally drift correct 2D topo automatically.

    Inputs:
        data        - Required : 2D array of topo after global shear correction, with bad pixels removed on the edge
        sigma       - Optional : Floating number specifying the size of mask to be used in phasemap()
        method      - Optional : Specifying which method to in phasemap()
                                "lockin": Spatial lock-in method to find phase map
                                "convolution": Gaussian mask convolution method to find phase map
        fixMethod   - Optional : Specifying which method to use in fixphaseslip()
                                "unwrap": fix phase jumps line by line in x direction and y direction, respectively
                                "spiral": fix phase slip in phase shift maps by flattening A into a 1D array in a spiral way
        show        - Optional : Boolean specifying if the results are plotted or not

    Returns:
        ux          - 2D array of drift field in x direction
        uy          - 2D array of drift field in y direction
        data_corr   - 2D array of topo after local drift corrected

    Usage:
        import stmpy.driftcorr as dfc
        ux, uy, data_corr = dfc.local_corr(data, sigma=5, method='lockin', fixMethod='unwrap', show=True)

    History:
        04/29/2019      RL : Initial commit.
    """
    imgsize = np.shape(data)[-1]
    bg_2 = findBraggs(data, min_dist=int(imgsize/10), thres=0.2, show=show)
    thetax, thetay, Q1, Q2= phasemap(data, bg_2, method=method, sigma=sigma)
    if show is True:
        fig,ax=plt.subplots(1,2,figsize=[8,4])
        ax[0].imshow(thetax, origin='lower')
        ax[1].imshow(thetay, origin='lower')
        fig.suptitle('Raw phase maps')
    thetaxf = fixphaseslip(thetax, method=fixMethod)
    thetayf = fixphaseslip(thetay, method=fixMethod)
    if show is True:
        fig,ax=plt.subplots(1,2,figsize=[8,4])
        ax[0].imshow(thetaxf, origin='lower')
        ax[1].imshow(thetayf, origin='lower')
        fig.suptitle('After fixing phase slips')
    ux, uy = driftmap(thetaxf, thetayf, Q1, Q2, method=method)
    if method=='lockin':
        data_corr = driftcorr(data, ux, uy, method='interpolate', interpolation='cubic')
    elif method=='convolution':
        data_corr = driftcorr(data, ux, uy, method='invfft',)
    else:
        print("Error: Only two methods are available, lockin or convolution.")
    if show is True:
        fig,ax=plt.subplots(2,2,figsize=[8, 8])
        ax[1, 0].imshow(data_corr, cmap=stmpy.cm.blue1,origin='lower')
        ax[1, 1].imshow(stmpy.tools.fft(data_corr, zeroDC=True), cmap=stmpy.cm.gray_r,origin='lower')
        ax[0, 0].imshow(data, cmap=stmpy.cm.blue1,origin='lower')
        ax[0, 1].imshow(stmpy.tools.fft(data, zeroDC=True), cmap=stmpy.cm.gray_r,origin='lower')
        fig.suptitle('Before and after local drift correction')
    return ux, uy, data_corr

def apply_df_3d(data, bg1, ux, uy, crop1=None, crop2=None, method='interpolate'):
    """
    Apply drift field (both global and local) found in 2D to corresponding 3D map.

    Inputs:
        data        - Required : 3D array of map to be drift corrected
        bg1         - Required : Coordinates of Bragg peaks returned by global_corr()
        ux          - Required : 2D array of drift field in x direction. Usually generated by local_corr()
        uy          - Required : 2D array of drift field in y direction. Usually generated by local_corr()
        crop1       - Optional : List of length 1 or length 4, specifying after global shear correction how much to crop on the edge
        crop2       - Optional : List of length 1 or length 4, specifying after local drift correction how much to crop on the edge
        method      - Optional : Specifying which method to apply the drift correction
                                    "interpolate": Interpolate A and then apply it to a new set of coordinates,
                                                    (x-ux, y-uy)
                                    "invfft": Used inversion fft to apply the drift fields
    Returns:
        data_corr   - 2D array of topo after local drift corrected

    Usage:
        import stmpy.driftcorr as dfc
        data_corr = dfc.apply_df_3d(data, bg1=bg1, ux=ux, uy=uy, crop1=[5], crop2=[5], method='interpolate')

    History:
        04/29/2019      RL : Initial commit.
    """
    data_c, _  = gshearcorr(data, bg1, rspace=True)
    if crop1 is None:
        data_c = data_c
    elif len(crop1) == 1:
        data_c = cropedge(data_c, crop1[0])
    elif len(crop1) == 4:
        edge_left, edge_right, edge_bottom, edge_top = crop1
        data_c = data_c[:,edge_bottom:edge_top+1,edge_left:edge_right+1]
    else:
        print("Please provide crop1 as 1-element or 4-element list.")
    data_corr = driftcorr(data_c, ux, uy, method=method, interpolation='cubic')
    if crop2 is None:
        data_out = data_corr
    elif len(crop2) == 1:
        data_out = cropedge(data_corr, crop2[0])
    elif len(crop2) == 4:
        edge_left, edge_right, edge_bottom, edge_top = crop2
        data_out = data_corr[:,edge_bottom:edge_top+1,edge_left:edge_right+1]
    else:
        print("Please provide crop2 as 1-element or 4-element list.")
    return data_out

